<p class="heading2" id="1">1. REST API</p>
<div class="paragraph-wrapper">
  <p class="paragraph">
    REST API, or Representational State Transfer Application Programming Interface, is a type of web API that uses HTTP requests to access and manipulate data. It is a popular way for developers to create web services that can be accessed by other applications. REST APIs are known for their simplicity, flexibility, and scalability, and are widely used in building modern web and mobile applications.<br><br>
    REST API is based on the REST architectural style, which is a set of principles and constraints for designing network-based software. <br>
    The main principles of the REST architectural style include:<br><br>
    • Client-server architecture<br>
    This principle separates the user interface concerns from the data storage concerns, allowing them to evolve independently.<br><br>
    • Statelessness<br>
    This principle ensures that each request from a client contains all the necessary information for the server to understand and process it. The server does not store any information about the client's state between requests.<br><br>
    • Cacheability<br>
    This principle allows responses to be cached, improving performance and scalability.<br><br>
    • Uniform interface<br>
    This principle provides a consistent and standardized way for clients to interact with the server, using HTTP verbs like GET, POST, PUT, and DELETE.<br><br>
    REST APIs use HTTP as the underlying protocol for communication. They typically use JSON or XML as the data format for requests and responses. The best practice is to use JSON because it is a light-weight data format, which means that it can be transmitted quickly over the network, it is easy to read and write, it is not tied to any specific programming language or platform, which means that it can be used by any application that supports JSON parsing and generation. <br>These make it a popular choice for creating APIs that can be used across different programming languages and platforms.
  </p>
</div>
<p class="heading2" id="2">2. CRUDable REST API</p>
<div class="paragraph-wrapper">
  <p class="paragraph">
    CRUDable REST API is a type of REST API that supports Create, Read, Update and Delete (CRUD) operations for resources. In a typical CRUDable REST API, each resource is identified by a unique URL, and clients can send HTTP requests to create, read, update, or delete the resource. Here's a brief overview of each operation.<br><br>
    Create (POST) is the operation used to create a new resource. The client sends a POST request to the source's URL with the data for the new resource in the request body.<br><br>
    In order to perform POST operation over a resource, we need a package called 'body-parser'. It is a Node.js body parsing middleware that parses incoming request bodies before they are handled by the handlers. It is available under the req.body property and allows for automatic inflation of gzip and deflate encodings. It provides four express middleware for parsing JSON, Text, URL-encoded, and raw data sets over an HTTP request body.<br>Install the package by running the command <a class="inline-code">npm install body-parser</a>. After, at the beginning of the app.js file, you have to write
  </p>
</div>
<div class="code-snippet-wrapper">
  <pre class="code-snippet-tab">
    <code>const bodyParser = require('body-parser');</code>
    <code>app.use(bodyParser.json());</code>
    <code>// Parses all the urlencoded bodies</code>
    <code>app.use(bodyParser.urlencoded({extended: true}))</code>
  </pre>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        Finally we can write the POST method as
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>app.post("/birds", (req, res) => {</code>
        <code>const body = req.body;</code>
      
        <code>let calculateId = ++currentId;//Prefix notation updates before</code>
        <code>const newBird = {id: calculateId, ...body};</code>
        <code>birds.push(newBird);</code>
      
        <code>res.send({data: newBird});</code>
      <code>})</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">Read (GET): This operation is used to retrieve a resource or a list of resources. The client sends a GET request to the resource's URL to retrieve the data.</p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>app.get("/birds/:id", (req, res) => {</code>
        <code>const requestedBird = birds.find(</code>
            <code>bird => bird.id === Number(req.params.id));</code>
      
        <code>if (!requestedBird) return res.sendStatus(404);</code>
      
        <code>res.send({data: requestedBird});</code>
      <code>});</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        Update (PUT or PATCH): This operation is used to update an existing resource. The client sends a   PUT or PATCH request to the resource's URL with the updated data in the request body.
        The main difference between PUT and PATCH HTTP methods is the level of modification they perform on a resource.<br><br>
        PUT is used to completely replace an existing resource with a new version. This means that the server will replace the entire resource with the new data provided in the request. If part of the resource is missing in the request, it will be replaced with null or empty values.
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>app.put("/birds/:id", (req,res) => {</code>
        <code>const requestedBird = birds.find(</code>
            <code>bird => bird.id === Number(req.params.id));</code>
              
        <code>if (!requestedBird) return res.sendStatus(404);</code>
               
        <code>requestedBird.name = req.body.name;</code>
        <code>requestedBird.maleRating = req.body.maleRating;</code>
        <code>requestedBird.femaleRating = req.body.femaleRating;</code>
                
        <code>res.send({data: requestedBird});</code>
    <code>});</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        PATCH, on the other hand, is used to update part of an existing resource with new data. This means that the server will modify only the fields or attributes specified in the request and leave the rest of the resource unchanged. This can be useful when you want to update a specific field or attribute without affecting the entire resource.
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>app.patch("/birds/:id", (req,res) => {</code>
        <code>const foundIndex = birds.findIndex(</code>
            <code>bird => bird.id === Number(req.params.id));</code>
          
        <code>if (!foundIndex === -1) {</code>
            <code>res.status(404).send(</code>
                <code>{message: `no bird found with id ${req.params.id}`})</code>
        <code>} else {</code>
            <code>const foundBird = birds[foundIndex];</code>
            <code>const birdToCreate = {...foundBird, ...req.body, id: foundBird.id}</code>
            <code>birds[foundIndex] = birdToCreate;</code>
            
            <code>res.send({birdToCreate})}</code>
    <code>});</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        Delete (DELETE): This operation is used to delete a resource. The client sends a DELETE request to the resource's URL to delete it.
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>app.delete("/birds/:id", (req,res) => {</code>
        <code>const requestedBirdIndex = birds.findIndex(</code>
            <code>bird => bird.id === Number(req.params.id));</code>
          
        <code>if (requestedBirdIndex === -1) {</code>
            <code>res.status(404).send(</code>
                <code>{data: requestedBirdIndex,</code>
                    <code>message: `no bird found with id: ${req.params.id}`});</code>
        <code>} else {</code>
            <code>birds.splice(requestedBirdIndex, 1)[0];</code>
            <code>res.sendStatus(200);}</code>
    <code>});</code>
        </pre>
    </div>
</div>
<div class="heading2" id="3">3. How to send data in a GET request</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        • Query String Parameters<br>
        You can send data in a GET request by including it in the URL as query string parameters. For example, you can send data to a server by appending it to the URL in the following format: ?key1=value1&key2=value2. The server can then extract the data from the query string parameters.<br><br>• URL path parameters<br>
        You can also send data in a GET request by including it in the URL path. This is typically done when the data is used to identify a specific resource. For example, you can send data to a server by including it in the URL path in the following format: /resource/:id, where :id is a variable that represents the data being sent.
    </p>
</div>
<div class="heading2" id="4">4. Serving HTML Files</div>
<div class="paragraph-wrapper">
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>//serve static files from the public directory</code>
    <code>app.use(express.static('public'));</code>

    <code>app.get('/', (req, res) => {</code>
        <code>res.sendFile(__dirname + '/public/index.html');</code>
    <code>});</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        In the example en we define a route for the root path '/'' and use the <a class="inline-code">res.sendFile</a> method to send the index.html file.<br>Note that we use the __dirname global variable to get the current directory path and append the public/index.html file path to it.<br><br>
        There are many ways to serve html files. Another way is to use 'path'.<br>
        The path module is a built-in module in Node.js that provides utilities for working with file and directory paths. It has several useful methods for manipulating and constructing paths in a cross-platform manner.<br><br>To install the path module using npm, you can open your terminal or command prompt and navigate to your project directory. Then, run the following command:
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
            <code>npm install path</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        Instead of using the syntax we have used until now that is
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
            <code>const path = require('path')</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        We can use the <a class="inline-code">import</a> keyword and start importing modules. In order to do that, we need to declare <a class="inline-code">"type": "module"</a> in the package.json file. This is the current package.json:
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>{</code>
        <code>"type": "module",</code>
        <code>"dependencies": {</code>
            <code>"express": "4.18.2"</code>
        <code>}</code>
    <code>}</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        So now can start import modules in our 'app.js' file like
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
            <code>import path from "path";</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        Finally we can see the second way of serving html file without <a class="inline-code">__dirname</a> but with the new imported module 'path'
    </p>
    <div class="code-snippet-wrapper">
        <pre class="code-snippet-tab">
    <code>//serve static files from the public directory</code>
    <code>app.use(express.static('public'));</code>

    <code>app.get('/', (req, res) => {</code>
        <code>res.sendFile(path.resolve('/public/index.html'));</code>
    <code>});</code>
        </pre>
    </div>
</div>
<div class="paragraph-wrapper">
    <p class="paragraph">
        <a class="inline-code">path.resolve()</a> and <a class="inline-code">__dirname</a> both serve similar purposes of returning absolute paths, but they differ in how they achieve this.<br><br><a class="inline-code">__dirname</a> is a global variable in Node.js that returns the absolute path of the directory containing the currently executing file.<br><br>On the other hand, <a class="inline-code">path.resolve()</a> is a method in the Node.js path module that returns an absolute path by resolving any relative paths or symbolic links. It can take any number of arguments to join together into one absolute path.
    </p>
</div>